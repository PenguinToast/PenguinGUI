<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>PenguinGUI Reference</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-56315532-1', 'auto');
      ga('require', 'displayfeatures');
      ga('send', 'pageview');

    </script>
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>PenguinGUI</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>



<h2>Source</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../source/test.lua.html">test.lua</a></li>
  <li><strong>inspect.lua</strong></li>
  <li><a href="../source/profilerapi.lua.html">profilerapi.lua</a></li>
  <li><a href="../source/binding.lua.html">binding.lua</a></li>
  <li><a href="../source/bindingfunctions.lua.html">bindingfunctions.lua</a></li>
  <li><a href="../source/button.lua.html">button.lua</a></li>
  <li><a href="../source/checkbox.lua.html">checkbox.lua</a></li>
  <li><a href="../source/component.lua.html">component.lua</a></li>
  <li><a href="../source/frame.lua.html">frame.lua</a></li>
  <li><a href="../source/gui.lua.html">gui.lua</a></li>
  <li><a href="../source/image.lua.html">image.lua</a></li>
  <li><a href="../source/label.lua.html">label.lua</a></li>
  <li><a href="../source/panel.lua.html">panel.lua</a></li>
  <li><a href="../source/radiobutton.lua.html">radiobutton.lua</a></li>
  <li><a href="../source/textbutton.lua.html">textbutton.lua</a></li>
  <li><a href="../source/textfield.lua.html">textfield.lua</a></li>
  <li><a href="../source/util.lua.html">util.lua</a></li>
  <li><a href="../source/ptguitestconsole.lua.html">ptguitestconsole.lua</a></li>
  <li><a href="../source/ptguitestobject.lua.html">ptguitestobject.lua</a></li>
</ul>
<h2>Modules</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../modules/Binding.html">Binding</a></li>
  <li><a href="../modules/GUI.html">GUI</a></li>
  <li><a href="../modules/PtUtil.html">PtUtil</a></li>
</ul>
<h2>Classes</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../classes/Button.html">Button</a></li>
  <li><a href="../classes/CheckBox.html">CheckBox</a></li>
  <li><a href="../classes/Component.html">Component</a></li>
  <li><a href="../classes/Frame.html">Frame</a></li>
  <li><a href="../classes/Image.html">Image</a></li>
  <li><a href="../classes/Label.html">Label</a></li>
  <li><a href="../classes/Panel.html">Panel</a></li>
  <li><a href="../classes/RadioButton.html">RadioButton</a></li>
  <li><a href="../classes/TextButton.html">TextButton</a></li>
  <li><a href="../classes/TextField.html">TextField</a></li>
</ul>

</div>

<div id="content">

    <h2>inspect.lua</h2>
<pre>
<span class="keyword">local</span> inspect ={
  _VERSION = <span class="string">'inspect.lua 3.0.0'</span>,
  _URL     = <span class="string">'http://github.com/kikito/inspect.lua'</span>,
  _DESCRIPTION = <span class="string">'human-readable representations of tables'</span>,
  _LICENSE = <span class="string">[[
    MIT LICENSE

    Copyright (c) 2013 Enrique Garc√≠a Cota

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  ]]</span>
}

inspect.KEY       = <span class="global">setmetatable</span>({}, {__tostring = <span class="keyword">function</span>() <span class="keyword">return</span> <span class="string">'inspect.KEY'</span> <span class="keyword">end</span>})
inspect.METATABLE = <span class="global">setmetatable</span>({}, {__tostring = <span class="keyword">function</span>() <span class="keyword">return</span> <span class="string">'inspect.METATABLE'</span> <span class="keyword">end</span>})

<span class="comment">-- Apostrophizes the string if it has quotes, but not aphostrophes
</span><span class="comment">-- Otherwise, it returns a regular quoted string
</span><span class="keyword">local</span> <span class="keyword">function</span> smartQuote(str)
  <span class="keyword">if</span> str:match(<span class="string">'"'</span>) <span class="keyword">and</span> <span class="keyword">not</span> str:match(<span class="string">"'"</span>) <span class="keyword">then</span>
    <span class="keyword">return</span> <span class="string">"'"</span> .. str .. <span class="string">"'"</span>
  <span class="keyword">end</span>
  <span class="keyword">return</span> <span class="string">'"'</span> .. str:gsub(<span class="string">'"'</span>, <span class="string">'\\"'</span>) .. <span class="string">'"'</span>
<span class="keyword">end</span>

<span class="keyword">local</span> controlCharsTranslation = {
  [<span class="string">"\a"</span>] = <span class="string">"\\a"</span>,  [<span class="string">"\b"</span>] = <span class="string">"\\b"</span>, [<span class="string">"\f"</span>] = <span class="string">"\\f"</span>,  [<span class="string">"\n"</span>] = <span class="string">"\\n"</span>,
  [<span class="string">"\r"</span>] = <span class="string">"\\r"</span>,  [<span class="string">"\t"</span>] = <span class="string">"\\t"</span>, [<span class="string">"\v"</span>] = <span class="string">"\\v"</span>
}

<span class="keyword">local</span> <span class="keyword">function</span> escapeChar(c) <span class="keyword">return</span> controlCharsTranslation[c] <span class="keyword">end</span>

<span class="keyword">local</span> <span class="keyword">function</span> escape(str)
  <span class="keyword">local</span> result = str:gsub(<span class="string">"\\", "</span>\\\\<span class="string">"):gsub("</span>(%c)<span class="string">", escapeChar)
  return result
end

local function isIdentifier(str)
  return type(str) == 'string' and str:match( "</span>^[_%a][_%a%d]*$<span class="string">" )
end

local function isSequenceKey(k, length)
  return type(k) == 'number'
     and 1 &lt;= k
     and k &lt;= length
     and math.floor(k) == k
end

local defaultTypeOrders = {
  ['number']   = 1, ['boolean']  = 2, ['string'] = 3, ['table'] = 4,
  ['function'] = 5, ['userdata'] = 6, ['thread'] = 7
}

local function sortKeys(a, b)
  local ta, tb = type(a), type(b)

  -- strings and numbers are sorted numerically/alphabetically
  if ta == tb and (ta == 'string' or ta == 'number') then return a &lt; b end

  local dta, dtb = defaultTypeOrders[ta], defaultTypeOrders[tb]
  -- Two default types are compared according to the defaultTypeOrders table
  if dta and dtb then return defaultTypeOrders[ta] &lt; defaultTypeOrders[tb]
  elseif dta     then return true  -- default types before custom ones
  elseif dtb     then return false -- custom types after default ones
  end

  -- custom types are sorted out alphabetically
  return ta &lt; tb
end

local function getNonSequentialKeys(t)
  local keys, length = {}, #t
  for k,_ in pairs(t) do
    if not isSequenceKey(k, length) then table.insert(keys, k) end
  end
  table.sort(keys, sortKeys)
  return keys
end

local function getToStringResultSafely(t, mt)
  local __tostring = type(mt) == 'table' and rawget(mt, '__tostring')
  local str, ok
  if type(__tostring) == 'function' then
    ok, str = pcall(__tostring, t)
    str = ok and str or 'error: ' .. tostring(str)
  end
  if type(str) == 'string' and #str &gt; 0 then return str end
end

local maxIdsMetaTable = {
  __index = function(self, typeName)
    rawset(self, typeName, 0)
    return 0
  end
}

local idsMetaTable = {
  __index = function (self, typeName)
    local col = setmetatable({}, {__mode = "</span>kv<span class="string">"})
    rawset(self, typeName, col)
    return col
  end
}

local function countTableAppearances(t, tableAppearances)
  tableAppearances = tableAppearances or setmetatable({}, {__mode = "</span>k<span class="string">"})

  if type(t) == 'table' then
    if not tableAppearances[t] then
      tableAppearances[t] = 1
      for k,v in pairs(t) do
        countTableAppearances(k, tableAppearances)
        countTableAppearances(v, tableAppearances)
      end
      countTableAppearances(getmetatable(t), tableAppearances)
    else
      tableAppearances[t] = tableAppearances[t] + 1
    end
  end

  return tableAppearances
end

local copySequence = function(s)
  local copy, len = {}, #s
  for i=1, len do copy[i] = s[i] end
  return copy, len
end

local function makePath(path, ...)
  local keys = {...}
  local newPath, len = copySequence(path)
  for i=1, #keys do
    newPath[len + i] = keys[i]
  end
  return newPath
end

local function processRecursive(process, item, path)
  if item == nil then return nil end

  local processed = process(item, path)
  if type(processed) == 'table' then
    local processedCopy = {}
    local processedKey

    for k,v in pairs(processed) do
      processedKey = processRecursive(process, k, makePath(path, k, inspect.KEY))
      if processedKey ~= nil then
        processedCopy[processedKey] = processRecursive(process, v, makePath(path, processedKey))
      end
    end

    local mt  = processRecursive(process, getmetatable(processed), makePath(path, inspect.METATABLE))
    setmetatable(processedCopy, mt)
    processed = processedCopy
  end
  return processed
end


-------------------------------------------------------------------

local Inspector = {}
local Inspector_mt = {__index = Inspector}

function Inspector:puts(...)
  local args   = {...}
  local buffer = self.buffer
  local len    = #buffer
  for i=1, #args do
    len = len + 1
    buffer[len] = tostring(args[i])
  end
end

function Inspector:down(f)
  self.level = self.level + 1
  f()
  self.level = self.level - 1
end

function Inspector:tabify()
  self:puts(self.newline, string.rep(self.indent, self.level))
end

function Inspector:alreadyVisited(v)
  return self.ids[type(v)][v] ~= nil
end

function Inspector:getId(v)
  local tv = type(v)
  local id = self.ids[tv][v]
  if not id then
    id              = self.maxIds[tv] + 1
    self.maxIds[tv] = id
    self.ids[tv][v] = id
  end
  return id
end

function Inspector:putKey(k)
  if isIdentifier(k) then return self:puts(k) end
  self:puts("</span>[<span class="string">")
  self:putValue(k)
  self:puts("</span>]")
<span class="keyword">end</span>

<span class="keyword">function</span> Inspector:putTable(t)
  <span class="keyword">if</span> t == inspect.KEY <span class="keyword">or</span> t == inspect.METATABLE <span class="keyword">then</span>
    self:puts(<span class="global">tostring</span>(t))
  <span class="keyword">elseif</span> self:alreadyVisited(t) <span class="keyword">then</span>
    self:puts(<span class="string">'&lt;table '</span>, self:getId(t), <span class="string">'&gt;'</span>)
  <span class="keyword">elseif</span> self.level &gt;= self.depth <span class="keyword">then</span>
    self:puts(<span class="string">'{...}'</span>)
  <span class="keyword">else</span>
    <span class="keyword">if</span> self.tableAppearances[t] &gt; <span class="number">1</span> <span class="keyword">then</span> self:puts(<span class="string">'&lt;'</span>, self:getId(t), <span class="string">'&gt;'</span>) <span class="keyword">end</span>

    <span class="keyword">local</span> nonSequentialKeys = getNonSequentialKeys(t)
    <span class="keyword">local</span> length            = #t
    <span class="comment">-- local mt                = getmetatable(t)
</span>    <span class="keyword">local</span> toStringResult    = getToStringResultSafely(t, mt)

    self:puts(<span class="string">'{'</span>)
    self:down(<span class="keyword">function</span>()
      <span class="keyword">if</span> toStringResult <span class="keyword">then</span>
        self:puts(<span class="string">' -- '</span>, escape(toStringResult))
        <span class="keyword">if</span> length &gt;= <span class="number">1</span> <span class="keyword">then</span> self:tabify() <span class="keyword">end</span>
      <span class="keyword">end</span>

      <span class="keyword">local</span> count = <span class="number">0</span>
      <span class="keyword">for</span> i=<span class="number">1</span>, length <span class="keyword">do</span>
        <span class="keyword">if</span> count &gt; <span class="number">0</span> <span class="keyword">then</span> self:puts(<span class="string">','</span>) <span class="keyword">end</span>
        self:puts(<span class="string">' '</span>)
        self:putValue(t[i])
        count = count + <span class="number">1</span>
      <span class="keyword">end</span>

      <span class="keyword">for</span> _,k <span class="keyword">in</span> <span class="global">ipairs</span>(nonSequentialKeys) <span class="keyword">do</span>
        <span class="keyword">if</span> count &gt; <span class="number">0</span> <span class="keyword">then</span> self:puts(<span class="string">','</span>) <span class="keyword">end</span>
        self:tabify()
        self:putKey(k)
        self:puts(<span class="string">' = '</span>)
        self:putValue(t[k])
        count = count + <span class="number">1</span>
      <span class="keyword">end</span>

      <span class="keyword">if</span> mt <span class="keyword">then</span>
        <span class="keyword">if</span> count &gt; <span class="number">0</span> <span class="keyword">then</span> self:puts(<span class="string">','</span>) <span class="keyword">end</span>
        self:tabify()
        self:puts(<span class="string">'&lt;metatable&gt; = '</span>)
        self:putValue(mt)
      <span class="keyword">end</span>
    <span class="keyword">end</span>)

    <span class="keyword">if</span> #nonSequentialKeys &gt; <span class="number">0</span> <span class="keyword">or</span> mt <span class="keyword">then</span> <span class="comment">-- result is multi-lined. Justify closing }
</span>      self:tabify()
    <span class="keyword">elseif</span> length &gt; <span class="number">0</span> <span class="keyword">then</span> <span class="comment">-- array tables have one extra space before closing }
</span>      self:puts(<span class="string">' '</span>)
    <span class="keyword">end</span>

    self:puts(<span class="string">'}'</span>)
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> Inspector:putValue(v)
  <span class="keyword">local</span> tv = <span class="global">type</span>(v)

  <span class="keyword">if</span> tv == <span class="string">'string'</span> <span class="keyword">then</span>
    self:puts(smartQuote(escape(v)))
  <span class="keyword">elseif</span> tv == <span class="string">'number'</span> <span class="keyword">or</span> tv == <span class="string">'boolean'</span> <span class="keyword">or</span> tv == <span class="string">'nil'</span> <span class="keyword">then</span>
    self:puts(<span class="global">tostring</span>(v))
  <span class="keyword">elseif</span> tv == <span class="string">'table'</span> <span class="keyword">then</span>
    self:putTable(v)
  <span class="keyword">else</span>
    self:puts(<span class="string">'&lt;'</span>,tv,<span class="string">' '</span>,self:getId(v),<span class="string">'&gt;'</span>)
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">-------------------------------------------------------------------
</span>
<span class="keyword">function</span> inspect.inspect(root, options)
  options       = options <span class="keyword">or</span> {}

  <span class="keyword">local</span> depth   = options.depth   <span class="keyword">or</span> <span class="global">math</span>.huge
  <span class="keyword">local</span> newline = options.newline <span class="keyword">or</span> <span class="string">'\n'</span>
  <span class="keyword">local</span> indent  = options.indent  <span class="keyword">or</span> <span class="string">'  '</span>
  <span class="keyword">local</span> process = options.process

  <span class="keyword">if</span> process <span class="keyword">then</span>
    root = processRecursive(process, root, {})
  <span class="keyword">end</span>

  <span class="keyword">local</span> inspector = <span class="global">setmetatable</span>({
    depth            = depth,
    buffer           = {},
    level            = <span class="number">0</span>,
    ids              = <span class="global">setmetatable</span>({}, idsMetaTable),
    maxIds           = <span class="global">setmetatable</span>({}, maxIdsMetaTable),
    newline          = newline,
    indent           = indent,
    tableAppearances = countTableAppearances(root)
  }, Inspector_mt)

  inspector:putValue(root)

  <span class="keyword">return</span> <span class="global">table</span>.concat(inspector.buffer)
<span class="keyword">end</span>

<span class="global">setmetatable</span>(inspect, { __call = <span class="keyword">function</span>(_, ...) <span class="keyword">return</span> inspect.inspect(...) <span class="keyword">end</span> })

<span class="keyword">return</span> inspect</pre>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.3</a></i>
<i style="float:right;">Last updated 2014-11-23 04:44:31 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
